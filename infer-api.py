from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional
import os
from acestep.pipeline_ace_step import ACEStepPipeline
import base64
from acestep.data_sampler import DataSampler
import uuid

app = FastAPI(title="ACEStep Pipeline API")


class ACEStepInput(BaseModel):
    """
    Input schema for the ACEStep inference API.

    The pipeline expects arguments in a strict positional order.  To make
    HTTP clients intuitive and prevent accidental misalignment, this
    dataclass mirrors the signature of :meth:`ACEStepPipeline.__call__`.

    Key points:

    * ``format`` comes first and defaults to ``"wav"``.  This
      determines the container for the generated audio (e.g. ``mp3``,
      ``wav``, ``flac``).

    * ``manual_seeds`` replaces the previous ``actual_seeds`` field.  It
      should be a list of integers and will be forwarded directly to the
      underlying pipeline's ``manual_seeds`` parameter, allowing
      deterministic generation when desired.  A new list is provided by
      callers or generated by the bot.

    * ``oss_steps`` accepts a list of integers.  These are optional
      one-shot sample steps.  They will be converted to the appropriate
      format by the pipeline; passing a list avoids accidental
      string/int confusion.
    """

    # Audio file format (wav, mp3, flac, ogg).  Defaults to "wav".
    format: str = "wav"

    checkpoint_path: str
    bf16: bool = True
    torch_compile: bool = False
    device_id: int = 0
    output_path: Optional[str] = None
    audio_duration: float
    prompt: str
    lyrics: str
    infer_step: int
    guidance_scale: float
    scheduler_type: str
    cfg_type: str
    omega_scale: float
    manual_seeds: List[int]
    guidance_interval: float
    guidance_interval_decay: float
    min_guidance_scale: float
    use_erg_tag: bool
    use_erg_lyric: bool
    use_erg_diffusion: bool
    oss_steps: List[int]
    guidance_scale_text: float = 0.0
    guidance_scale_lyric: float = 0.0


class ACEStepOutput(BaseModel):
    status: str
    output_path: Optional[str]
    message: str
    # Base64‑encoded audio data.  When present, callers can use this
    # instead of reading the file directly from disk.  It is encoded
    # using standard Base64 and does not include a data URI prefix.
    audio_data: Optional[str] = None


def initialize_pipeline(
    checkpoint_path: str, bf16: bool, torch_compile: bool, device_id: int
) -> ACEStepPipeline:
    """
    Initialise the ACEStep pipeline with the given checkpoint and device.
    """
    os.environ["CUDA_VISIBLE_DEVICES"] = str(device_id)
    return ACEStepPipeline(
        checkpoint_dir=checkpoint_path,
        dtype="bfloat16" if bf16 else "float32",
        torch_compile=torch_compile,
    )


@app.post("/generate", response_model=ACEStepOutput)
async def generate_audio(input_data: ACEStepInput):
    """
    Generate an audio file from the supplied parameters.

    This function constructs a tuple of positional arguments in the
    order expected by `ACEStepPipeline.__call__` and forwards them to
    the pipeline.  The first argument is `format`, followed by
    `audio_duration`, `prompt`, etc.  See `pipeline_ace_step.py` for
    details on the signature.  A fully-qualified `output_path` is
    generated when one is not provided.
    """
    try:
        # Initialise the underlying diffusion pipeline
        model_demo = initialize_pipeline(
            input_data.checkpoint_path,
            input_data.bf16,
            input_data.torch_compile,
            input_data.device_id,
        )

        # Construct the argument tuple for the call.  See
        # ``acestep/pipeline_ace_step.py:ACEStepPipeline.__call__`` for
        # parameter ordering.  Note that the first nine entries map
        # directly to the corresponding named arguments, followed by
        # ``manual_seeds`` (formerly ``actual_seeds``) and the rest of
        # the optional controls.  We pass seeds and one‑shot steps as
        # lists of integers directly to avoid downstream string parsing.
        params = (
            input_data.format,
            input_data.audio_duration,
            input_data.prompt,
            input_data.lyrics,
            input_data.infer_step,
            input_data.guidance_scale,
            input_data.scheduler_type,
            input_data.cfg_type,
            input_data.omega_scale,
            input_data.manual_seeds,
            input_data.guidance_interval,
            input_data.guidance_interval_decay,
            input_data.min_guidance_scale,
            input_data.use_erg_tag,
            input_data.use_erg_lyric,
            input_data.use_erg_diffusion,
            input_data.oss_steps,
            input_data.guidance_scale_text,
            input_data.guidance_scale_lyric,
        )

        # Generate output_path if not provided; default to WAV
        output_path = (
            input_data.output_path
            or f"output_{uuid.uuid4().hex}.{input_data.format}"
        )

        # Execute the pipeline.  Positional arguments must match the
        # signature of ACEStepPipeline.__call__.  We pass save_path
        # explicitly as a keyword argument.
        model_demo(
            *params,
            save_path=output_path,
        )

        # After generation, attempt to read the produced file and
        # encode it as Base64.  This makes the audio portable even
        # when the client cannot access the server's filesystem.  If
        # reading the file fails (e.g. missing, permission error), we
        # silently ignore and return only the path.
        audio_data = None
        try:
            with open(output_path, "rb") as f:
                audio_bytes = f.read()
                audio_data = base64.b64encode(audio_bytes).decode("ascii")
        except Exception:
            audio_data = None

        return ACEStepOutput(
            status="success",
            output_path=output_path,
            message="Audio generated successfully",
            audio_data=audio_data,
        )

    except Exception as e:
        # Wrap any exception in an HTTPException for FastAPI
        raise HTTPException(status_code=500, detail=f"Error generating audio: {str(e)}")


@app.get("/health")
async def health_check():
    """
    Simple health check endpoint.
    """
    return {"status": "healthy"}


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)
